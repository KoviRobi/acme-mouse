* Default mouse bindings
#+BEGIN_SRC elisp
  (seq-sort (lambda (a b)
              (string-lessp (symbol-name (car a))
                            (symbol-name (car b))))
   (seq-filter (lambda (binding)
                 (and
                  (consp binding)
                  (symbolp (car binding))
                  (string-match ".*mouse.*" (symbol-name (car binding)))))
               (current-global-map)))
#+END_SRC
* Action stuff
#+BEGIN_SRC elisp :tangle acme-mouse-new.el
  (makunbound 'acme-mouse)
  (makunbound 'acme-mouse-map)

  ;; Transitions
  (setq acme-mouse-transition-table
        '((none (down left) left mouse-drag-region)
          (none (down middle) middle
                (acme-mouse-face-remap 'acme-mouse-region-eval)
                mouse-drag-secondary)
          (none (down right) right
                (acme-mouse-face-remap 'acme-mouse-region-search)
                mouse-drag-secondary)

          (left (down middle) left-middle
                acme-mouse-cut)
          (left (down right) left-right
                acme-mouse-paste)

          ;; Mouse up
          (left (up left) none            ;acme-mouse-lmb
                mouse-set-point)
          (middle (up middle) none        ;mouse-yank-primary
                  mouse-start-secondary
                  (acme-mouse-face-unmap)
                  (selection-or-point acme-mouse-eval 'sexp))
          (right (up right) none          ;mouse-save-then-kill
                  mouse-start-secondary
                 (acme-mouse-face-unmap)
                 (selection-or-point acme-mouse-search 'word))

          (left-middle (up middle) left)
          (left-right (up right) left)

          ;; Mouse drag up
          (left (drag left) none mouse-set-region)
          (middle (drag middle) none
                  mouse-set-secondary
                  (acme-mouse-face-unmap)
                  (selected-region acme-mouse-eval))
          (right (drag right) none
                 mouse-set-secondary
                 (acme-mouse-face-unmap)
                 (selected-region acme-mouse-search))))
#+END_SRC

#+BEGIN_SRC elisp :tangle acme-mouse-new.el
  (defmacro selection-or-point (command point-type)
    `(lambda (click)
       (let ((clicked (posn-point (event-end click))))
         (if (and (<= (mark) clicked (point)) (use-region-p))
             (progn (message "Sel") (,command click (mark) (point)))
           (let ((bounds (bounds-of-thing-at-point ,point-type)))
             (message "Point")
             (,command click (car bounds) (cdr bounds)))))))

  (defmacro selected-region (command)
    `(lambda (click)
       (let* ((start (posn-point (event-start click)))
              (end (posn-point (event-start click)))
              (lo (min start end))
              (hi (max start end)))
         (,command click lo hi))))
#+END_SRC

#+BEGIN_SRC elisp :tangle acme-mouse-new.el
  (defvar acme-mouse-state 'none
    "The state of the chording state-machine.")

  (defvar acme-mouse-remapping nil
    "The remapping applied to the region face.")

  (defvar acme-mouse-start-click nil
    "The start click of the transition from 'none state, set to
    nil on a transition back to 'none state.")
#+END_SRC

#+BEGIN_SRC elisp :tangle acme-mouse-new.el
  (defun acme-mouse-face-unmap ()
    (when acme-mouse-remapping
      (face-remap-remove-relative acme-mouse-remapping)
      (setq acme-mouse-remapping nil)))

  (defun acme-mouse-face-remap (face)
    (acme-mouse-face-unmap)
    (setq acme-mouse-remapping (face-remap-add-relative 'secondary-selection face)))


  (defun acme-mouse-cut (click)
    (interactive "e")
    (let ((beg (posn-point (event-start acme-mouse-start-click)))
          (end (posn-point (event-end click)))
          (clicks (event-click-count acme-mouse-start-click)))
      (mouse-start-end beg end (1- clicks))
      (message "last: %S\tcut: %S" (eq last-command 'yank) click)
      (if (eq last-command 'yank)
          (undo)
        (kill-region (mark) (point))
        ;;(setq this-command 'kill-region)
        )))

  (defun acme-mouse-paste (click)
    (interactive "e")
    (let ((beg (posn-point (event-start acme-mouse-start-click)))
          (end (posn-point (event-end click)))
          (clicks (event-click-count acme-mouse-start-click)))
      (mouse-start-end beg end (1- clicks))
      (message "last: %S\tpaste: %S" (eq last-command 'kill-region) click)
      (if (eq last-command 'kill-region)
          (undo)
        (yank))))

  (defun acme-mouse-eval (click lo hi)
    (message "eval %S %S %S" click lo hi))

  (defun acme-mouse-search (click lo hi)
    (message "search %S %S %S" click lo hi))
#+END_SRC
* State-machine driver
If we only change the state, then we want to do that transparently,
hence setting the ~last-command~.
#+BEGIN_SRC elisp :tangle acme-mouse-new.el
  (defmacro acme-mouse-make-transition (&rest input)
    `(lambda (click)
       (interactive "e")
       (setq this-command last-command)   ; Transparent
       (when (eq acme-mouse-state 'none)
         (setq acme-mouse-start-click click))
       (cond
        ,@(seq-map (lambda (el)
                     (seq-let [start _ end &rest functions] el
                       `((equal acme-mouse-state ',start)
                         (setq acme-mouse-state ',end)
                         ,@(seq-map (lambda (f)
                                      (if (commandp f t)
                                          `(progn
                                             (setq this-command ',f)
                                             (call-interactively ',f))
                                        `,f))
                                    functions))))
                   (seq-filter (lambda (el)
                                 (seq-let [_ label _ _] el
                                   (equal label input)))
                               acme-mouse-transition-table))
        (t (setq acme-mouse-state 'none)))
       (when (eq acme-mouse-state 'none)
         (setq acme-mouse-start-click click))))

#+END_SRC
* Minor Mode
#+BEGIN_SRC elisp :tangle acme-mouse-new.el
  (defgroup acme-mouse nil
    "Acme mouse chording mode for Emacs"
    :group 'mouse)

  (defface acme-mouse-region-eval
    '((((class color) (min-colors 8))
       :inverse-video t :foreground "dark red")
      (t :inverse-video t))
    "Face for selecting with the middle mouse button."
    :group 'acme-mouse)

  (defface acme-mouse-region-search
    '((((class color) (min-colors 8))
       :inverse-video t :foreground "dark green")
      (t :inverse-video t))
    "Face for selecting with the right mouse button."
    :group 'acme-mouse)

  ;; TODO double and triple clicks?
  (defvar acme-mouse-map
    (let ((keymap (make-sparse-keymap)))
      (define-key keymap [(down-mouse-1)] (acme-mouse-make-transition down left))
      (define-key keymap [(down-mouse-2)] (acme-mouse-make-transition down middle))
      (define-key keymap [(down-mouse-3)] (acme-mouse-make-transition down right))
      (define-key keymap [(mouse-1)] (acme-mouse-make-transition up left))
      (define-key keymap [(mouse-2)] (acme-mouse-make-transition up middle))
      (define-key keymap [(mouse-3)] (acme-mouse-make-transition up right))
      (define-key keymap [(drag-mouse-1)] (acme-mouse-make-transition drag left))
      (define-key keymap [(drag-mouse-2)] (acme-mouse-make-transition drag middle))
      (define-key keymap [(drag-mouse-3)] (acme-mouse-make-transition drag right))
      keymap)
    "Keymap for `acme-mouse` mode.")

  ;;;###autoload
  (define-minor-mode acme-mouse
    "Acme mouse mode enables the button actions of Acme:
    ,* Chording left and middle cuts the region
    ,* Chording left and middle pastes at point
    ,* Clicking with middle evaluates elisp sexp before point
    ,* Clicking with right searches word at point
    ,* Dragging with middle evaluates selected region as elisp expression
    ,* Dragging with right searches region"
    nil
    " Acme-Mouse"
    acme-mouse-map
    :group 'acme-mouse
    :global t)

  (provide 'acme-mouse)
  (acme-mouse)
#+END_SRC
