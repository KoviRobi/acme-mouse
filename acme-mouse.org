* Default mouse bindings
#+BEGIN_SRC elisp :exports both
  (pp (sort (cl-reduce (lambda (acc binding)
                         (if (and
                              (consp binding)
                              (symbolp (car binding))
                              (string-match ".*mouse.*" (symbol-name (car binding))))
                             (cons binding acc)
                           acc))
                       (current-global-map)
                       :initial-value nil)
            (lambda (a b)
              (string-lessp (symbol-name (car a))
                            (symbol-name (car b))))))
#+END_SRC

#+RESULTS:
#+begin_example
((C-down-mouse-1 . mouse-buffer-menu)
 (C-down-mouse-2 . facemenu-menu)
 (C-down-mouse-3 menu-item "Menu Bar" ignore :filter
                 (lambda
                   (_)
                   (if
                       (zerop
                        (or
                         (frame-parameter nil 'menu-bar-lines)
                         0))
                       (mouse-menu-bar-map)
                     (mouse-menu-major-mode-map))))
 (C-mouse-4 . mwheel-scroll)
 (C-mouse-5 . mwheel-scroll)
 (C-mouse-6 lambda nil
            (interactive)
            (setq truncate-lines nil))
 (C-mouse-7 lambda nil
            (interactive)
            (setq truncate-lines t))
 (M-down-mouse-1 . mouse-drag-secondary)
 (M-drag-mouse-1 . mouse-set-secondary)
 (M-mouse-1 . mouse-start-secondary)
 (M-mouse-2 . mouse-yank-secondary)
 (M-mouse-3 . mouse-secondary-save-then-kill)
 (S-down-mouse-1 . mouse-appearance-menu)
 (S-mouse-3 . kmacro-end-call-mouse)
 (S-mouse-4 . mwheel-scroll)
 (S-mouse-5 . mwheel-scroll)
 (double-mouse-1 . mouse-set-point)
 (down-mouse-1 . mouse-drag-region)
 (drag-mouse-1 . mouse-set-region)
 (mouse-1 . mouse-set-point)
 (mouse-2 . mouse-yank-primary)
 (mouse-3 . mouse-save-then-kill)
 (mouse-4 lambda nil
          (interactive)
          (scroll-down 1))
 (mouse-5 lambda nil
          (interactive)
          (scroll-up 1))
 (mouse-6 lambda nil
          (interactive)
          (when truncate-lines
            (scroll-right 1 t)))
 (mouse-7 lambda nil
          (interactive)
          (when truncate-lines
            (scroll-left 1 t)))
 (mouse-movement . ignore)
 (triple-mouse-1 . mouse-set-point))
#+end_example

* Action stuff
#+BEGIN_SRC elisp :tangle acme-mouse-new.el :noweb yes
  ;; -*- lexical-binding: t -*-
  (makunbound 'acme-mouse)
  (makunbound 'acme-mouse-map)

  <<Macros>>

  ;; Transitions
  (setq acme-mouse-transition-table
        `((none (down left) left mouse-drag-region)
          (none (down middle) middle
                (acme-mouse-face-remap 'acme-mouse-region-eval)
                mouse-drag-region)
          (none (down right) right
                (acme-mouse-face-remap 'acme-mouse-region-search)
                mouse-drag-region)

          (left (down middle) left-middle
                acme-mouse-cut)
          (left (down right) left-right
                acme-mouse-paste)

          ;; Mouse up
          (left (up left) none            ;acme-mouse-lmb
                mouse-set-point)
          (middle (up middle) none        ;mouse-yank-primary
                  mouse-set-point
                  (acme-mouse-face-unmap)
                  ,(selection-or-point 'acme-mouse-eval 'sexp))
          (right (up right) none          ;mouse-save-then-kill
                 mouse-set-point
                 (acme-mouse-face-unmap)
                 ,(selection-or-point 'acme-mouse-search 'word))

          (left-middle (up middle) left)
          (left-right (up right) left)

          ;; Mouse drag up
          (left (drag left) none mouse-set-region)
          (middle (drag middle) none
                  mouse-set-region
                  (acme-mouse-face-unmap)
                  ,(selected-region acme-mouse-eval))
          (right (drag right) none
                 mouse-set-region
                 (acme-mouse-face-unmap)
                 ,(selected-region acme-mouse-search))))
#+END_SRC

#+NAME: Macros
#+BEGIN_SRC elisp
  (defun acme-mouse-selection (click)
    (let* ((start (posn-point (event-start acme-mouse-start-click)))
           (end (posn-point (event-start click)))
           (clicks (event-click-count acme-mouse-start-click)))
      (mouse-start-end start end (1- clicks))))

  (defmacro selection-or-point (command point-type)
    `(lambda (click)
       (interactive "e")
       (let* ((clicked (posn-point (event-end click)))
              (bounds (bounds-of-thing-at-point ,point-type)))
         (cond ((and (<= (mark) clicked (point)) (use-region-p)))
               (funcall ,command click
                        (buffer-substring (mark) (point)))
               ((or (not (car bounds)) (not (cdr bounds)))
                (funcall ,command click
                         (buffer-substring (car bounds) (cdr bounds))))
               (t (funcall ,command click (elisp--preceding-sexp)))))))

  (defmacro selected-region (command)
    `(lambda (click)
       (interactive "e")
       (setq this-command ',command)
       (funcall ',command click
                (apply 'buffer-substring (acme-mouse-selection click)))))
#+END_SRC

#+BEGIN_SRC elisp :tangle acme-mouse-new.el
  (defvar acme-mouse-state 'none
    "The state of the chording state-machine.")

  (defvar acme-mouse-remapping nil
    "The remapping applied to the region face.")

  (defvar acme-mouse-start-click nil
    "The start click of the transition from 'none state, set to
    nil on a transition back to 'none state.")
#+END_SRC

#+BEGIN_SRC elisp :tangle acme-mouse-new.el
  (defun acme-mouse-face-unmap ()
    (when acme-mouse-remapping
      (face-remap-remove-relative acme-mouse-remapping)
      (setq acme-mouse-remapping nil)))

  (defun acme-mouse-face-remap (face)
    (acme-mouse-face-unmap)
    (setq acme-mouse-remapping (face-remap-add-relative 'region face)))

  (defun acme-mouse-cut (click)
    (interactive "e")
    (if (eq last-command 'yank)
        (undo)
      (apply 'kill-region (acme-mouse-selection click))))

  (defun acme-mouse-paste (click)
    (interactive "e")
    (if (eq last-command 'kill-region)
        (undo)
      (yank)))

  (defun acme-mouse-eval (click str)
    (message "eval %S" str))

  (defun acme-mouse-search (click str)
    (message "search %S" str))
#+END_SRC
* State-machine driver
If we only change the state, then we want to do that transparently,
hence setting the ~last-command~.
#+BEGIN_SRC elisp :tangle acme-mouse-new.el
  (defmacro acme-mouse-make-transition (&rest input)
    `(lambda (click)
       (interactive "e")
       (setq this-command last-command)   ; Transparent
       (when (eq acme-mouse-state 'none)
         (setq acme-mouse-start-click click))
       (cond
        ,@(cl-reduce (lambda (acc transition)
                       (pcase transition
                         (`(,start ,(pred (equal input)) ,end . ,funs)
                          `(foo . ,acc)
                          (cons
                           `((equal acme-mouse-state ',start)
                             (setq acme-mouse-state ',end)
                             ,@(apply 'append
                                      (cl-mapcar
                                       (lambda (f)
                                         (if (commandp f t)
                                             `((setq this-command ',f)
                                               (call-interactively ',f))
                                           `(,f)))
                                       funs)))
                           acc))
                         (_ acc)))
                     acme-mouse-transition-table
                     :initial-value nil)
        (t (setq acme-mouse-state 'none)))
       (when (eq acme-mouse-state 'none)
         (setq acme-mouse-start-click nil))))
#+END_SRC
* Minor Mode
#+BEGIN_SRC elisp :tangle acme-mouse-new.el
  (defgroup acme-mouse nil
    "Acme mouse chording mode for Emacs"
    :group 'mouse)

  (defface acme-mouse-region-eval
    '((((class color) (min-colors 8))
       :inverse-video t :foreground "dark red")
      (t :inverse-video t))
    "Face for selecting with the middle mouse button."
    :group 'acme-mouse)

  (defface acme-mouse-region-search
    '((((class color) (min-colors 8))
       :inverse-video t :foreground "dark green")
      (t :inverse-video t))
    "Face for selecting with the right mouse button."
    :group 'acme-mouse)

  ;; TODO double and triple clicks?
  (defvar acme-mouse-map
    (let ((keymap (make-sparse-keymap)))
      (define-key keymap [(down-mouse-1)] (acme-mouse-make-transition down left))
      (define-key keymap [(down-mouse-2)] (acme-mouse-make-transition down middle))
      (define-key keymap [(down-mouse-3)] (acme-mouse-make-transition down right))
      (define-key keymap [(mouse-1)] (acme-mouse-make-transition up left))
      (define-key keymap [(mouse-2)] (acme-mouse-make-transition up middle))
      (define-key keymap [(mouse-3)] (acme-mouse-make-transition up right))
      (define-key keymap [(double-mouse-1)] (acme-mouse-make-transition up left))
      (define-key keymap [(double-mouse-2)] (acme-mouse-make-transition up middle))
      (define-key keymap [(double-mouse-3)] (acme-mouse-make-transition up right))
      (define-key keymap [(triple-mouse-1)] (acme-mouse-make-transition up left))
      (define-key keymap [(triple-mouse-2)] (acme-mouse-make-transition up middle))
      (define-key keymap [(triple-mouse-3)] (acme-mouse-make-transition up right))
      (define-key keymap [(drag-mouse-1)] (acme-mouse-make-transition drag left))
      (define-key keymap [(drag-mouse-2)] (acme-mouse-make-transition drag middle))
      (define-key keymap [(drag-mouse-3)] (acme-mouse-make-transition drag right))
      keymap)
    "Keymap for `acme-mouse` mode.")

  ;;;###autoload
  (define-minor-mode acme-mouse
    "Acme mouse mode enables the button actions of Acme:
    ,* Chording left and middle cuts the region
    ,* Chording left and middle pastes at point
    ,* Clicking with middle evaluates elisp sexp before point
    ,* Clicking with right searches word at point
    ,* Dragging with middle evaluates selected region as elisp expression
    ,* Dragging with right searches region"
    nil
    " Acme-Mouse"
    acme-mouse-map
    :group 'acme-mouse
    :global t)

  (provide 'acme-mouse)
  (acme-mouse)
#+END_SRC
